// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: playlist_audio.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const countPlaylistAudiosByAudioID = `-- name: CountPlaylistAudiosByAudioID :one
SELECT COUNT(1) FROM playlist_audios WHERE audio_id = $1
`

func (q *Queries) CountPlaylistAudiosByAudioID(ctx context.Context, audioID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPlaylistAudiosByAudioID, audioID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPlaylistAudio = `-- name: CreatePlaylistAudio :one
INSERT INTO playlist_audios(
  id,
  playlist_id,
  audio_id,
  created_at
) VALUES ($1,$2,$3,$4) 
RETURNING id, created_at, playlist_id, audio_id
`

type CreatePlaylistAudioParams struct {
	ID         uuid.UUID
	PlaylistID uuid.UUID
	AudioID    uuid.UUID
	CreatedAt  time.Time
}

func (q *Queries) CreatePlaylistAudio(ctx context.Context, arg CreatePlaylistAudioParams) (PlaylistAudio, error) {
	row := q.db.QueryRowContext(ctx, createPlaylistAudio,
		arg.ID,
		arg.PlaylistID,
		arg.AudioID,
		arg.CreatedAt,
	)
	var i PlaylistAudio
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.PlaylistID,
		&i.AudioID,
	)
	return i, err
}

const deletePlaylistAudiosByIDs = `-- name: DeletePlaylistAudiosByIDs :exec
DELETE FROM playlist_audios 
  WHERE playlist_id = $1
  AND audio_id = ANY($2::uuid[])
`

type DeletePlaylistAudiosByIDsParams struct {
	PlaylistID uuid.UUID
	AudioIds   []uuid.UUID
}

func (q *Queries) DeletePlaylistAudiosByIDs(ctx context.Context, arg DeletePlaylistAudiosByIDsParams) error {
	_, err := q.db.ExecContext(ctx, deletePlaylistAudiosByIDs, arg.PlaylistID, pq.Array(arg.AudioIds))
	return err
}

const deletePlaylistAudiosByPlaylistID = `-- name: DeletePlaylistAudiosByPlaylistID :exec
DELETE FROM playlist_audios WHERE playlist_id = $1
`

func (q *Queries) DeletePlaylistAudiosByPlaylistID(ctx context.Context, playlistID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePlaylistAudiosByPlaylistID, playlistID)
	return err
}

const getPlaylistAudioIDsByPlaylistIDs = `-- name: GetPlaylistAudioIDsByPlaylistIDs :many
SELECT id
FROM playlist_audios
WHERE playlist_id = ANY($1::uuid[])
`

func (q *Queries) GetPlaylistAudioIDsByPlaylistIDs(ctx context.Context, playlistIds []uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, getPlaylistAudioIDsByPlaylistIDs, pq.Array(playlistIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaylistAudioJoinsBySpotifyIDs = `-- name: GetPlaylistAudioJoinsBySpotifyIDs :many
SELECT 
  playlist_audios.id, playlist_audios.created_at, playlist_audios.playlist_id, playlist_audios.audio_id,
  audios.spotify_id AS spotify_id
FROM playlist_audios
INNER JOIN audios ON playlist_audios.audio_id = audios.id
WHERE playlist_audios.playlist_id = $1 AND audios.spotify_id = ANY($2::text[])
`

type GetPlaylistAudioJoinsBySpotifyIDsParams struct {
	PlaylistID uuid.UUID
	SpotifyIds []string
}

type GetPlaylistAudioJoinsBySpotifyIDsRow struct {
	ID         uuid.UUID
	CreatedAt  time.Time
	PlaylistID uuid.UUID
	AudioID    uuid.UUID
	SpotifyID  sql.NullString
}

func (q *Queries) GetPlaylistAudioJoinsBySpotifyIDs(ctx context.Context, arg GetPlaylistAudioJoinsBySpotifyIDsParams) ([]GetPlaylistAudioJoinsBySpotifyIDsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPlaylistAudioJoinsBySpotifyIDs, arg.PlaylistID, pq.Array(arg.SpotifyIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlaylistAudioJoinsBySpotifyIDsRow
	for rows.Next() {
		var i GetPlaylistAudioJoinsBySpotifyIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.PlaylistID,
			&i.AudioID,
			&i.SpotifyID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaylistAudios = `-- name: GetPlaylistAudios :many
SELECT
  playlist_audios.id AS playlist_audio_id,
  playlist_audios.created_at AS playlist_audio_created_at,
  playlist_audios.playlist_id AS playlist_audio_playlist_id,
  playlist_audios.audio_id AS playlist_audio_audio_id,

  audios.id AS audio_id,
  audios.created_at AS audio_created_at,
  audios.title AS audio_title,
  audios.author AS audio_author,
  audios.duration_ms AS audio_duration_ms,
  audios.path AS audio_path,
  audios.size_bytes AS audio_size_bytes,
  audios.youtube_video_id AS audio_youtube_video_id,
  audios.thumbnail_path AS audio_thumbnail_path,
  audios.spotify_id AS audio_spotify_id,
  audios.thumbnail_url AS audio_thumbnail_url,
  audios.local_id AS audio_local_id,

  audio_likes.id AS audio_likes_id,
  audio_likes.created_at AS audio_likes_created_at,
  audio_likes.audio_id AS audio_likes_audio_id,
  audio_likes.user_id AS audio_likes_user_id
FROM playlist_audios
LEFT JOIN audios ON playlist_audios.audio_id = audios.id
LEFT JOIN audio_likes ON playlist_audios.audio_id = audio_likes.audio_id AND audio_likes.user_id = $1 
WHERE ($2::uuid[] IS NULL OR playlist_audios.playlist_id = ANY($2::uuid[])) 
  AND ($3::uuid[] IS NULL OR playlist_audios.id = ANY($3::uuid[]))
ORDER BY audios.title ASC
`

type GetPlaylistAudiosParams struct {
	UserID      uuid.UUID
	PlaylistIds []uuid.UUID
	Ids         []uuid.UUID
}

type GetPlaylistAudiosRow struct {
	PlaylistAudioID         uuid.UUID
	PlaylistAudioCreatedAt  time.Time
	PlaylistAudioPlaylistID uuid.UUID
	PlaylistAudioAudioID    uuid.UUID
	AudioID                 uuid.NullUUID
	AudioCreatedAt          sql.NullTime
	AudioTitle              sql.NullString
	AudioAuthor             sql.NullString
	AudioDurationMs         sql.NullInt32
	AudioPath               sql.NullString
	AudioSizeBytes          sql.NullInt64
	AudioYoutubeVideoID     sql.NullString
	AudioThumbnailPath      sql.NullString
	AudioSpotifyID          sql.NullString
	AudioThumbnailUrl       sql.NullString
	AudioLocalID            sql.NullString
	AudioLikesID            uuid.NullUUID
	AudioLikesCreatedAt     sql.NullTime
	AudioLikesAudioID       uuid.NullUUID
	AudioLikesUserID        uuid.NullUUID
}

func (q *Queries) GetPlaylistAudios(ctx context.Context, arg GetPlaylistAudiosParams) ([]GetPlaylistAudiosRow, error) {
	rows, err := q.db.QueryContext(ctx, getPlaylistAudios, arg.UserID, pq.Array(arg.PlaylistIds), pq.Array(arg.Ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlaylistAudiosRow
	for rows.Next() {
		var i GetPlaylistAudiosRow
		if err := rows.Scan(
			&i.PlaylistAudioID,
			&i.PlaylistAudioCreatedAt,
			&i.PlaylistAudioPlaylistID,
			&i.PlaylistAudioAudioID,
			&i.AudioID,
			&i.AudioCreatedAt,
			&i.AudioTitle,
			&i.AudioAuthor,
			&i.AudioDurationMs,
			&i.AudioPath,
			&i.AudioSizeBytes,
			&i.AudioYoutubeVideoID,
			&i.AudioThumbnailPath,
			&i.AudioSpotifyID,
			&i.AudioThumbnailUrl,
			&i.AudioLocalID,
			&i.AudioLikesID,
			&i.AudioLikesCreatedAt,
			&i.AudioLikesAudioID,
			&i.AudioLikesUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
